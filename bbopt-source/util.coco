"""
Utilities for use across all of bbopt.
"""

import os
import sys
from collections.abc import Mapping, Iterable

import numpy as np


Num = (int, float)
Str = (str, py_str)


def norm_path(path) =
    """Normalize the given path."""
    (path
    |> os.path.expanduser
    |> os.path.abspath
    |> os.path.realpath
    |> os.path.normcase)


def isnumpy(obj):
    """Determines if obj is a numpy scalar."""
    return type(obj).__module__ == "numpy" and np.isscalar(obj)


def denumpy(obj, fallback=None):
    """Convert numpy data types to their Python equivalents."""
    # the ordering here is extremely important; float must
    #  come before int and int must come before bool
    if np.issubdtype(obj, np.complexfloating):
        return complex(obj)
    if np.issubdtype(obj, np.floating):
        return float(obj)
    if np.issubdtype(obj, np.signedinteger) or np.issubdtype(obj, np.unsignedinteger):
        return int(obj)
    if np.issubdtype(obj, np.bool_):
        return bool(obj)
    if np.issubdtype(obj, np.str_) or np.issubdtype(obj, np.unicode_):
        return str(obj)
    if fallback is not None:
        fallback()
    return obj


def denumpy_all(obj):
    """Recursively apply denumpy to the given obj."""
    if isinstance(obj, (list, tuple)):
        return obj |> fmap$(denumpy_all)
    elif isinstance(obj, dict):
        return {
            denumpy_all(k): denumpy_all(v)
            for k, v in obj.items()
        }
    elif isnumpy(obj):
        return denumpy(obj)
    else:
        return obj


def json_serialize(obj):
    """Serialize obj for encoding in JSON."""
    if obj is None or isinstance(obj, (int, float, bool, str)):
        return obj
    if isinstance(obj, bytes):
        return str(obj, encoding="utf-8")
    if isinstance(obj, Mapping):
        serialized_dict = {}
        for k, v in obj.items():
            serialized_k = json_serialize(k)
            if not isinstance(serialized_k, str):
                raise TypeError("dict keys must be strings, not {}".format(k))
            serialized_dict[k] = json_serialize(v)
        return serialized_dict
    if isinstance(obj, Iterable):
        serialized_list = []
        for x in obj:
            serialized_list.append(json_serialize(x))
        return serialized_list
    if isnumpy(obj):
        return denumpy(obj, fallback=(def -> raise TypeError("cannot JSON serialize numpy dtype {}".format(obj.dtype))))
    raise TypeError("cannot JSON serialize {}".format(obj))


def sorted_items(params) =
    """Return an iterator of the dict's items sorted by its keys."""
    sorted(params.items())


def best_example(examples):
    """Return the best example seen so far."""
    selected_example = {"values": {}}
    max_gain, min_loss = None, None
    for example in examples:
        case example:
            match {"values": values, "gain": gain, **_}:
                if min_loss is not None:
                    raise ValueError("cannot have examples with maximize and examples with minimize")
                if max_gain is None or gain >= max_gain:
                    selected_example = example
                    max_gain = gain
            match {"values": values, "loss": loss, **_}:
                if max_gain is not None:
                    raise ValueError("cannot have examples with maximize and examples with minimize")
                if min_loss is None or loss <= min_loss:
                    selected_example = example
                    min_loss = loss
        else:
            raise ValueError(f"invalid example {example}")
    return selected_example


def all_isinstance(objs, types) =
    """Return whether all the objects have the desired type(s)."""
    objs |> map$(isinstance$(?, types)) |> all


def format_err(Error, message, obj) =
    """Creates an error with a formatted error message."""
    Error(message + ": " + repr(obj))


def sync_file(file_handle):
    """Forcibly flush and sync the given file."""
    file_handle.flush()
    os.fsync(file_handle.fileno())


def ensure_file(fpath):
    """Ensure that the given file exists."""
    if sys.version_info >= (3,):
        try:
            with open(fpath, "x"):
                pass
        except FileExistsError:
            pass
    else:
        with open(fpath, "a"):
            pass


def clear_file(file_handle):
    """Empties the contents of the given file."""
    file_handle.seek(0)
    file_handle.truncate()
